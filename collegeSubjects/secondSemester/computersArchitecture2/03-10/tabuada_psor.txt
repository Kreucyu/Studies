/* Main.c file generated by New Project wizard
 *
 * Created:   qui ago 8 2024
 * Processor: 8086
 * Compiler:  Digital Mars C
 *
 * Before starting simulation set Internal Memory Size 
 * in the 8086 model properties to 0x10000
 */

#define IO0 0x0000
#define IO1 0x0200
#define IO2 0x0400
#define IO3 0x0600
#define IO4 0x0800
#define IO5 0x0A00
#define IO6 0x0C00
#define IO7 0x0E00
#define IO8 0x1000
#define IO9 0x1200
#define IO10 0x1400
#define IO11 0x1600
#define IO12 0x1800
#define IO13 0x1a00
#define IO14 0x1c00
#define IO15 0x1e00

// 8251A USART 
// USART = UNIVERSAL SERIAL ASSYNCRONOUS RECEIVER TRANSMITER

#define ADR_USART_DATA   (IO6 + 00h)
//ONDE VOCE VAI MANDAR E RECEBER DADOS DO 8251

#define ADR_USART_CMD   (IO6 + 02h)
//É O LOCAL ONDE VOCE VAI ESCREVER PARA PROGRAMAR O 8251
//WRITE

#define ADR_USART_STAT  (IO6 + 02h)
//RETORNA O STATUS SE UM CARACTER FOI DIGITADO NO TERMINAL
//RETORNA O STATUS SE POSSO TRANSMITIR CARACTER PARA O TERMINAL
//READ

unsigned char HORA;
unsigned char MINUTO;

#define TAM_STRING 64
#define TAM_BYTE 2
char Mensagem1[] = {"MIGUEL ALEXANDRE WISINTAINER"};
char Mensagem2[TAM_STRING+1];
unsigned char Contador_Teclas_Digitadas;
char NUMERO[3];

void MANDAR_CARACTER(void);

char Mens1[] = "Entre com o numero da tabuada";
char Mens2[] = " * ";
char Mens3[] = " = ";
char Mens4[] = "Numero nao pode ser maior que 9";

char Num_Tab;

//nao tem parametro, basta chamar para pular linha
void PULAR_LINHA(void)
{ asm 
	{
		pushf
		push ax
		mov al, 13
		call MANDAR_CARACTER
		mov al, 10
		call MANDAR_CARACTER
		pop ax
		popf
	}
}

//Esta funcao imprimira um string apontada por BX
void MANDAR_STRING(void)
{
	asm {
		pushf
		push ax
COMPARA:
		mov al, [bx]
		cmp al, 0 //compara se é NULL
		je SAI_MANDAR_STRING
		call MANDAR_CARACTER
		inc bx
		jmp COMPARA
SAI_MANDAR_STRING:
		pop ax
		popf
	}
}

void RECEBER_CARACTER(void);

void RECEBER_STRING(void)
{
	asm {
			pushf
			push ax
			mov Contador_Teclas_Digitadas, 0
le_caracter:
			call RECEBER_CARACTER
			cmp al, 13 //se pressionou enter
			je TRATA_CR
			cmp al, 8  //ou backspace
			je TRATA_BS
			cmp Contador_Teclas_Digitadas, TAM_STRING
			je le_caracter
			mov [bx], al
			inc bx
			inc Contador_Teclas_Digitadas
			call MANDAR_CARACTER
			jmp le_caracter			
TRATA_CR:
			mov byte ptr [bx],0  //coloca null
			jmp SAI_RECEBER_STRING
TRATA_BS:
			cmp Contador_Teclas_Digitadas, 0
			je le_caracter
			dec bx
			mov byte ptr [bx], 0 //opcional
			dec Contador_Teclas_Digitadas
			mov al, 8 //backspace
			call MANDAR_CARACTER
			jmp le_caracter
SAI_RECEBER_STRING:
			pop ax
			popf
	}
}

void RECEBER_BYTE(void)
{
	asm {
			pushf
			push cx //cl filho
			mov Contador_Teclas_Digitadas, 0
			mov bx, OFFSET NUMERO
le_caracter:
			call RECEBER_CARACTER
			cmp al, 13 //se pressionou enter
			je TRATA_CR
			cmp al, 8  //ou backspace
			je TRATA_BS
			cmp Contador_Teclas_Digitadas, TAM_BYTE
			je le_caracter
			cmp al,'0'
			jl le_caracter
			cmp al,'9'
			jg le_caracter
			mov [bx], al
			inc bx
			inc Contador_Teclas_Digitadas
			call MANDAR_CARACTER
			jmp le_caracter			
TRATA_CR:
			cmp Contador_Teclas_Digitadas,2
			jne le_caracter
			mov byte ptr [bx],0  //coloca null
			jmp SAI_RECEBER_STRING
TRATA_BS:
			cmp Contador_Teclas_Digitadas, 0
			je le_caracter
			dec bx
			mov byte ptr [bx], 0 //opcional
			dec Contador_Teclas_Digitadas
			mov al, 8 //backspace
			call MANDAR_CARACTER
			jmp le_caracter
SAI_RECEBER_STRING:
			dec bx
			dec bx
			sub byte ptr [bx],48  //2
			inc bx
			sub byte ptr [bx],48  //3
			dec bx
			mov al, [bx]
			mov cl, 10
			mul cl
			inc bx
			add ax, byte ptr [bx]
			pop cx
			popf
	}
}

//certificar que AL tenha o numero a ser impresso
//AL = 17
void MANDAR_NUMERO(void)
{
 _asm
 {
      pushf
      push ax //pq estas salvando al, se al é parametro ? na verdade estou salvando ah
      push bx
      //DIV 
      //DIV XX
      //AX <= AX / XX ---> RESTO --> AH       QUOCIENTE ----> AL
      mov ah, 0
      mov bh, 10
      div bh
      // AX / bh ===> teremos em AH = 7 e em AL = 1
      add al,'0' // 1 ---> "1"
      call MANDAR_CARACTER
      add ah,'0' // 7 ---> "7"
      mov al,ah // move "7" para Al para ser impresso!!!!!!!!!!!!!
      call MANDAR_CARACTER
      pop bx
      pop ax
      popf
 }  
}

//19200,8,N,1
void INICIALIZA_8251(void)
{
   _asm {
   MOV AL,0
   MOV DX, ADR_USART_CMD
   OUT DX,AL
   OUT DX,AL
   OUT DX,AL
   MOV AL,40H
   OUT DX,AL
   MOV AL,4DH
   OUT DX,AL
   MOV AL,37H
   OUT DX,AL
      }
}
//TENHA CERTEZA QUE O CARACTER ESTEJA EM AL
//AL É A PASSAGEM DE PARAMETRO - (POR REGISTRADOR)
void MANDAR_CARACTER(void)
{
   _asm {
      PUSHF  ; SALVA FLAGS Z E C
      PUSH DX
      PUSH AX  ; SALVA AL   AX = AH/AL
BUSY:
      MOV DX, ADR_USART_STAT
      IN  AL,DX
      TEST AL,1 ; 0000000S
      JZ BUSY
      MOV DX, ADR_USART_DATA
      POP AX  ; RESTAURA AL
      OUT DX,AL
      POP DX
      POPF ; RESTAURA FLAGS Z E C
   }  
}

//AO TERMINO DESTA ROTINA, TEREMOS EM AL
//O CODIGO ASCII DA TECLA DIGITADA
void RECEBER_CARACTER(void)
{
   _asm {
      PUSHF
      PUSH DX
AGUARDA_CARACTER:
      MOV DX, ADR_USART_STAT
      IN  AL,DX
      TEST AL,2 ;000000S0
      JZ AGUARDA_CARACTER
      MOV DX, ADR_USART_DATA
      IN AL,DX
      SHR AL,1 
NAO_RECEBIDO:
      POP DX
      POPF
   }
}



void Esperar_288_ms(void)
{
	asm 
	{
		mov cx, 54612 
decrementa:
		dec cx
		cmp cx, 0
		jne decrementa
	}
}

//esta rotina levará aproximadamente 288mS para executar
void Esperar_1_Segundo(void)
{
	asm 
	{
		call Esperar_288_ms
		call Esperar_288_ms
		call Esperar_288_ms
		call Esperar_288_ms
	}
}

void Inicializa_Relogio(void)
{
	asm {
			mov HORA, 0
			mov MINUTO, 0
		}
}

void Atualiza_Relogio(void)
{
	asm {
			inc MINUTO
			cmp MINUTO, 60
			je  ZERA_MINUTO
			jmp SAI_Atualiza_Relogio
ZERA_MINUTO:
			mov MINUTO,0
			inc HORA
			cmp HORA,24
			je  ZERA_HORA
			jmp SAI_Atualiza_Relogio
ZERA_HORA:
			mov HORA,0
			jmp SAI_Atualiza_Relogio
SAI_Atualiza_Relogio:
		}
}

void Mostra_Relogio(void)
{
	asm {
			//HORA de 8 bits
			//AX de bits 16 bits
			mov al, HORA
			mov ah, 0 //pode ter sujeira
			//ax = 00000000000010001
			mov bl, 10
			div bl
			//al = quociente ah = resto			
            //al = 1 ah = 7
			mov dx, IO2  
			out dx, al 
			mov al, ah
			mov dx, IO3   
			out dx, al		
			mov al, MINUTO
			mov ah, 0
			mov bl, 10
			div bl
			//al = quociente ah = resto
            //al = 2 e ah = 3
			mov dx, IO4
			out dx, al // 2			
			mov dx, IO5
			mov al, ah
			out dx, al // 3
		}
}

void main(void)
 {
  INICIALIZA_8251();

  while(1)
	{
		asm {
NUMERO:
				mov bx, offset Mens1
				call MANDAR_STRING
				call PULAR_LINHA
				call RECEBER_BYTE //al
				mov Num_Tab,al
				call PULAR_LINHA
				cmp  al, 9
				jg   ERROR
			}
				for(char i=0;i<=10;i++)
				{
					asm {
						mov al, Num_Tab
						call MANDAR_NUMERO
						mov bx, offset Mens2
						call MANDAR_STRING
						mov al, i
						call MANDAR_NUMERO
						mov bx, offset Mens3
						call MANDAR_STRING
						mov bl, Num_Tab
						mov al, i
						mul bl //al = resposta = AX
						call MANDAR_NUMERO
						call PULAR_LINHA
					}						
				}
			asm jmp fim
			asm {
ERROR:
				mov bx, offset Mens4
				call MANDAR_STRING
				call PULAR_LINHA
				jmp NUMERO
fim:
				}
	}


  while(1)
  {
	asm
	{
		call RECEBER_BYTE //retorna em AL 
		call PULAR_LINHA
		call MANDAR_NUMERO //imprimir AL
		call PULAR_LINHA
	}
  }
  //asm call INICIALIZA_8251
  Inicializa_Relogio();
 
  while(1)
  {
   asm {
		
		call Atualiza_Relogio
		call Mostra_Relogio
		call Esperar_1_Segundo
	}
  }
 }