/* Main.c file generated by New Project wizard
 *
 * Created:   qui ago 8 2024
 * Processor: 8086
 * Compiler:  Digital Mars C
 *
 * Before starting simulation set Internal Memory Size 
 * in the 8086 model properties to 0x10000
 */

#define IO0  0000h
#define IO1  0200h
#define IO2  0400h
#define IO3  0600h
#define IO4  0800h
#define IO5  0A00h
#define IO6  0C00h
#define IO7  0E00h
#define IO8  1000h
#define IO9  1200h
#define IO10 1400h
#define IO11 1600h
#define IO12 1800h
#define IO13 1A00h
#define IO14 1C00h
#define IO15 1E00H

//ENDEREÇOS DOS REGISTRADORES DO 8255
#define ADR_PPI_PORTA	  (IO7)
#define ADR_PPI_PORTB	  (IO7 + 02h)
#define ADR_PPI_PORTC	  (IO7 + 04h)
#define ADR_PPI_CONTROL   (IO7 + 06h)

#define PPI_PORTA_INP	  10h //00010000
#define PPI_PORTA_OUT	  00h
#define PPI_PORTB_INP	  02h
#define PPI_PORTB_OUT	  00h
#define PPI_PORTCL_INP	  01h //00000001
#define PPI_PORTCL_OUT	  00h
#define PPI_PORTCH_INP	  08h
#define PPI_PORTCH_OUT	  00h
#define PPI_MODE_BCL_0	  00h
#define PPI_MODE_BCL_1	  04h
#define PPI_MODE_ACH_0	  00h
#define PPI_MODE_ACH_1	  20h  //00100000
#define PPI_MODE_ACH_2	  40h  //01000000
#define PPI_ACTIVE	  80h  //10000000

//USART
//UNIVERSAL SERIAL ASSYNCRONOUS RECEIVER AND TRANSMITTER

// 8251A USART 
#define ADR_USART_DATA   (IO6 + 00h) 
//ONDE VOCE VAI MANDAR E RECEBER DADOS DO 8251

#define ADR_USART_CMD   (IO6 + 02h) 
//É O LOCAL ONDE VOCE VAI ESCREVER PARA PROGRAMAR O 8251
//WRITE 0C02H

#define ADR_USART_STAT  (IO6 + 02h)
//RETORNA O STATUS SE UM CARACTER FOI DIGITADO NO TERMINAL
//RETORNA O STATUS SE POSSO TRANSMITIR CARACTER PARA O TERMINAL

void RECEBER_CARACTER(void);

unsigned char HORA = 0;
unsigned char MINUTO = 0;

char Numero_Digitado;

//==================
char Mensagem1[] = {"ABRACADABRA"}; // 
#define TAM_MAX_STRING 64
#define TAM_MAX_BYTE 2
char Mensagem2[TAM_MAX_STRING+1]; //+1 espaco null
char Mensagem3[TAM_MAX_BYTE+1];
char Quantidade_Caracteres_Digitados;
char NUMERO[3]; //utilizado somente por RECEBER_BYTE
//==================

char Mens1[] = "Entre com o Numero";
char Mens2[] = " * ";
char Mens3[] = " = ";
char Mens4[] = "NUMERO NAO PODE SER MAIOR QUE 9";
char Mens5[] = "Contador: ";

char TECLA;
char CONTADOR = 0;

//---------------------------------------------------------
// ROTINAS PARA 8255   
void INICIALIZA_8255(void)
{
   _asm {
   PUSHF
   PUSH AX
   PUSH DX
   MOV DX, ADR_PPI_CONTROL
   MOV AL,0
   OR AL,PPI_PORTA_OUT
   OR AL,PPI_PORTB_OUT  
   OR AL,PPI_PORTCL_INP        
   OR AL,PPI_PORTCH_INP
   OR AL,PPI_MODE_BCL_0
   OR AL,PPI_MODE_ACH_0
   OR AL,PPI_ACTIVE
   OUT DX,AL
   POP DX
   POP AX
   POPF
   }      
}

//esta rotina escreve em PORT A o valor do registrador AL
void MANDAR_PORT_A(void)
{
   _asm
   {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTA
    OUT DX,AL
    POP DX
    POPF
   }
}

//esta funcao retorna em AL o conteudo lido da entrada PORT C
void LER_PORT_C(void)
{
   _asm {
    PUSHF
    PUSH DX
    MOV DX,ADR_PPI_PORTC
    IN AL,DX
    POP DX
    POPF
   }
}



//19200,8,N,1
void INICIALIZA_8251(void)
{
   _asm {
   MOV AL,0
   MOV DX, ADR_USART_CMD
   OUT DX,AL
   OUT DX,AL
   OUT DX,AL
   MOV AL,40H
   OUT DX,AL
   MOV AL,4DH
   OUT DX,AL
   MOV AL,37H
   OUT DX,AL
      }
}

//TENHA CERTEZA QUE O CARACTER ESTEJA EM AL
//AL É A PASSAGEM DE PARAMETRO - (POR REGISTRADOR)
void MANDAR_CARACTER(void)
{
   _asm {
      PUSHF  ; SALVA FLAGS Z E C
      PUSH DX
      PUSH AX  ; SALVA AL   AX = AH/AL
BUSY:
      MOV DX, ADR_USART_STAT
      IN  AL,DX
      TEST AL,1 ; 0000000S
      JZ BUSY
      MOV DX, ADR_USART_DATA
      POP AX  ; RESTAURA AL
      OUT DX,AL
      POP DX
      POPF ; RESTAURA FLAGS Z E C
   }  
}

//BX SERÁ O PONTEIRO PARA STRING
void MANDAR_STRING(void)
{
	asm {
			pushf
			push ax
		Imprimindo:
			mov al,[BX] 
			cmp al, 0 //null
			je  SAI_MANDAR_STRING
			call MANDAR_CARACTER
			inc bx
			jmp Imprimindo
SAI_MANDAR_STRING:
			pop ax
			popf
	}
}

//bx deve apontar para string vazia
void RECEBER_STRING(void)
{
	asm {
			pushf
			push ax
			mov Quantidade_Caracteres_Digitados,0
	Lendo_Caracter:
			call RECEBER_CARACTER
			cmp al, 13 //enter
			je  TRATA_ENTER
			cmp al, 8  //backspace
			je  TRATA_BACKSPACE
			cmp Quantidade_Caracteres_Digitados, TAM_MAX_STRING
			je  Lendo_Caracter
			mov [bx], al //salva al na memoria
			call MANDAR_CARACTER
			inc bx
			inc Quantidade_Caracteres_Digitados
			jmp Lendo_Caracter			
TRATA_ENTER:
			mov byte ptr [bx], 0
			jmp SAI_RECEBER_STRING
TRATA_BACKSPACE:
			cmp Quantidade_Caracteres_Digitados,0
			je Lendo_Caracter
			dec bx
		    dec Quantidade_Caracteres_Digitados
			mov byte ptr [bx], 0 //poe null
			mov al, 8 //imprimir backspace
			call MANDAR_CARACTER
			jmp Lendo_Caracter
SAI_RECEBER_STRING:
			pop ax
			popf
	}
}

//certificar que AL tenha o numero a ser impresso
//AL = 17
void MANDAR_BYTE(void)
{
 _asm
 {
      pushf
      push ax //pq estas salvando al, se al é parametro ? na verdade estou salvando ah
      push bx
      //DIV 
      //DIV XX
      //AX <= AX / XX ---> RESTO --> AH       QUOCIENTE ----> AL
      mov ah, 0
      mov bh, 10
      div bh
      // AX / bh ===> teremos em AH = 7 e em AL = 1
      add al,'0' // 1 ---> "1"
      call MANDAR_CARACTER
      add ah,'0' // 7 ---> "7"
      mov al,ah // move "7" para Al para ser impresso!!!!!!!!!!!!!
      call MANDAR_CARACTER
      pop bx
      pop ax
      popf
 }  
}

//bx deve apontar para string vazia
void RECEBER_BYTE(void)
{
	asm {
			pushf
			push cx
			mov Quantidade_Caracteres_Digitados,0
			mov bx, offset NUMERO
	Lendo_Caracter:
			call RECEBER_CARACTER
			cmp al, 13 //enter
			je  TRATA_ENTER
			cmp al, 8  //backspace
			je  TRATA_BACKSPACE
			cmp Quantidade_Caracteres_Digitados, TAM_MAX_BYTE
			je  Lendo_Caracter
			cmp al,'0'
			jl Lendo_Caracter
			cmp al,'9'
			jg Lendo_Caracter
			mov [bx], al //salva al na memoria
			call MANDAR_CARACTER
			inc bx
			inc Quantidade_Caracteres_Digitados
			jmp Lendo_Caracter			
TRATA_ENTER:
			cmp Quantidade_Caracteres_Digitados,0
			je Lendo_Caracter
			cmp Quantidade_Caracteres_Digitados,2
			jl Lendo_Caracter
			mov byte ptr [bx], 0
			dec bx
			dec bx
			sub byte ptr [bx], '0'
			inc bx
			sub byte ptr [bx], '0'
			dec bx
			mov al, [bx]
			mov cl, 10
			mul cl // ax = al * cl
			inc bx
			add ax, byte ptr [bx] //al = o byte!!!
			jmp SAI_RECEBER_STRING
TRATA_BACKSPACE:
			cmp Quantidade_Caracteres_Digitados,0
			je Lendo_Caracter
			dec bx
		    dec Quantidade_Caracteres_Digitados
			mov byte ptr [bx], 0 //poe null
			mov al, 8 //imprimir backspace
			call MANDAR_CARACTER
			jmp Lendo_Caracter
SAI_RECEBER_STRING:
			pop cx
			popf
	}
}


void PULAR_LINHA(void)
{
	asm {
		pushf
		push ax
		mov al, 13
		call MANDAR_CARACTER
		mov al, 10
		call MANDAR_CARACTER
		pop ax
		popf
	}
}

//AO TERMINO DESTA ROTINA, TEREMOS EM AL
//O CODIGO ASCII DA TECLA DIGITADA
void RECEBER_CARACTER(void)
{
   _asm {
      PUSHF
      PUSH DX
AGUARDA_CARACTER:
      MOV DX, ADR_USART_STAT
      IN  AL,DX
      TEST AL,2 ;000000S0
      JZ AGUARDA_CARACTER
      MOV DX, ADR_USART_DATA
      IN AL,DX
      SHR AL,1 
NAO_RECEBIDO:
      POP DX
      POPF
   }
}

void Inicializa_Relogio(void)
{
	HORA = 0;
	MINUTO = 0;
}

void Delay_288(void)
{
	asm 
	{
		mov cx, 54612 //4
	decrement:
		dec cx //2
		cmp cx, 0 //4
		jne decrement //16
	}
}

void Delay(void)
{
	asm {
	call Delay_288
	call Delay_288
	call Delay_288
	call Delay_288
	}
}

void Atualiza_Relogio(void)
{
	asm {
		inc MINUTO
		cmp MINUTO, 60
		je  ZERA_MINUTO
		jmp Sai_Atualiza_Relogio

ZERA_MINUTO:
		mov MINUTO, 0
		inc HORA
		cmp HORA, 24
		je  ZERA_HORA
		jmp Sai_Atualiza_Relogio

ZERA_HORA:
		mov HORA, 0
   	    jmp Sai_Atualiza_Relogio //opcional
	
Sai_Atualiza_Relogio:	
	}
}

void Mostra_Relogio(void)
{
	asm {
		mov al, HORA
		mov ah, 0 //apaga residuo
		mov bl, 10
		div bl // ah = resto, al = quociente
		mov dx, IO2
		out dx, al
		mov dx, IO3
		mov al, ah
		out dx, al
		mov al, MINUTO
		mov ah, 0  //apaga residuo
		mov bl, 10
		div bl // ah = resto, al = cociente
		mov dx, IO4
		out dx, al
		mov dx, IO5
		mov al, ah
		out dx, al
	}
}

void Seleciona_Linha_A(void)
{
	asm {
		pushf
		push ax
		push dx
		mov  al, 0b1110
		call MANDAR_PORT_A
		pop dx
		pop ax
		popf
	}
}

void Seleciona_Linha_B(void)
{
	asm {
		pushf
		push ax
		push dx
		mov  al, 0b1101
		call MANDAR_PORT_A
		pop dx
		pop ax
		popf
	}
}

void Seleciona_Linha_C(void)
{
	asm {
		pushf
		push ax
		push dx
		mov  al, 0b1011
		call MANDAR_PORT_A
		pop dx
		pop ax
		popf
	}
}

void Seleciona_Linha_D(void)
{
	asm {
		pushf
		push ax
		push dx
		mov  al, 0b0111
		call MANDAR_PORT_A
		pop dx
		pop ax
		popf
	}
}

void AGUARDAR_SOLTAR_TECLA(void)
{
      _asm
      {
	 pushf
	 push ax
	 Espera_Soltar_Tecla_Aguardando:
	    call LER_PORT_C
	    cmp al, 0b1111
	    je  Espera_Soltar_Tecla_Sai
	    jmp Espera_Soltar_Tecla_Aguardando
Espera_Soltar_Tecla_Sai:	 
	 pop ax
	 popf
      }
      
}

void LER_TECLADO(void)
{
	asm {
			call Seleciona_Linha_A			
			call LER_PORT_C
			cmp  al, 0b0111
			je	 TECLA_7 
			cmp  al, 0b1011
			je   TECLA_8
			cmp  al, 0b1101
			je   TECLA_9
			cmp  al, 0b1110		
			je   TECLA_DIV
			call Seleciona_Linha_B			
			call LER_PORT_C
			cmp  al, 0b0111
			je	 TECLA_4 
			cmp  al, 0b1011
			je   TECLA_5
			cmp  al, 0b1101
			je   TECLA_6
			cmp  al, 0b1110		
			je   TECLA_MUL
			call Seleciona_Linha_C			
			call LER_PORT_C
			cmp  al, 0b0111
			je	 TECLA_1 
			cmp  al, 0b1011
			je   TECLA_2
			cmp  al, 0b1101
			je   TECLA_3
			cmp  al, 0b1110		
			je   TECLA_SUB
			call Seleciona_Linha_D			
			call LER_PORT_C
			cmp  al, 0b0111
			je	 TECLA_C 
			cmp  al, 0b1011
			je   TECLA_0
			cmp  al, 0b1101
			je   TECLA_IGUAL
			cmp  al, 0b1110		
			je   TECLA_SOM

			mov cl, 0 //null
			jmp SAIDA_LER_TECLADO

TECLA_7:
			mov cl, '7'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_8:
			mov cl, '8'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_9:
			mov cl, '9'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_DIV:
			mov cl, '/'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
			
TECLA_4:
			mov cl, '4'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_5:
			mov cl, '5'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_6:
			mov cl, '6'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_MUL:
			mov cl, '*'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_1:
			mov cl, '1'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_2:
			mov cl, '2'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_3:
			mov cl, '3'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_SUB:
			mov cl, '-'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_C:
			mov cl, 'C'
			mov CONTADOR, 0
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO			
TECLA_0:
			mov cl, '0'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_IGUAL:
			mov cl, '='
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO
TECLA_SOM:
			mov cl, '+'
			call AGUARDAR_SOLTAR_TECLA
			jmp SAIDA_LER_TECLADO

SAIDA_LER_TECLADO:			
			mov TECLA, cl

	}
}

void main(void)
 {
	INICIALIZA_8251();
	INICIALIZA_8255();

	while(1)
	{
		asm {
LENDO:
				call LER_TECLADO
				cmp TECLA, 0 //null
				je LENDO
				mov al, TECLA
				call MANDAR_CARACTER
				cmp TECLA, '-'
				je DECREMENTA
				cmp  TECLA, '+'
				je INCREMENTA
				cmp TECLA, 'C'
				je ZERA
				jmp IMPRIMINDO
IMPRIMINDO:
				mov bx, offset Mens5
				call PULAR_LINHA
				call MANDAR_STRING
				mov al, CONTADOR
				call MANDAR_BYTE
				call PULAR_LINHA
				JMP LENDO
	
ZERA:
				mov CONTADOR, 0
				jmp IMPRIMINDO
		   
DECREMENTA:
				cmp CONTADOR, 0
				je CONTADOR_9
				dec CONTADOR
				jmp IMPRIMINDO
				
INCREMENTA:
				cmp CONTADOR, 9
				je CONTADOR_0
				INC CONTADOR
				jmp IMPRIMINDO			
CONTADOR_0:
		   
      mov CONTADOR, 0
      call AGUARDAR_SOLTAR_TECLA
      jmp IMPRIMINDO
      
CONTADOR_9:
      mov CONTADOR, 9
      call AGUARDAR_SOLTAR_TECLA
      jmp IMPRIMINDO
			}
	}


	while(1)
	{
		asm {
INICIO:
			mov bx, offset Mens1
			call MANDAR_STRING
			call PULAR_LINHA
			call RECEBER_BYTE  //al
			cmp  al, 9
			jg   ERROR
			mov Numero_Digitado, al
			call PULAR_LINHA
			jmp FOR
ERROR:
			call PULAR_LINHA
			mov bx, offset Mens4
			call MANDAR_STRING
			call PULAR_LINHA
			jmp INICIO

		}
FOR:
		for(char i=0; i<=10; i++)
			{
				asm {
						mov al, Numero_Digitado
						call MANDAR_BYTE
						mov bx, offset Mens2
						call MANDAR_STRING
						mov al, i
						call MANDAR_BYTE
						mov bx, offset Mens3
						call MANDAR_STRING
						mov bl, Numero_Digitado  //07
						mov al, i
						mul bl
						call MANDAR_BYTE
						call PULAR_LINHA
					}
			}			
	}



	while(1)
	{ asm {
			call RECEBER_BYTE  //al tem o byte
			call PULAR_LINHA
			call MANDAR_BYTE //al tem o parametro
			call PULAR_LINHA
	  }
	}
	Inicializa_Relogio();
    Mostra_Relogio();

	while(1)
	{
		asm {
			call Atualiza_Relogio
			call Mostra_Relogio //joga display
			call Delay
		}
	}
 }
